// Copyright 2022 Flavien Charlon
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace QuickConstructor.Generator;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

public class SourceRenderer
{
  private static readonly SymbolDisplayFormat ParameterFormat = SymbolDisplayFormat.FullyQualifiedFormat
    .WithMiscellaneousOptions(
      SymbolDisplayFormat.FullyQualifiedFormat.MiscellaneousOptions
      | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

  public string Render(ConstructorDescriptor constructorDescriptor)
  {
    var classSymbol = constructorDescriptor.ClassSymbol;
    IReadOnlyList<ConstructorParameter> parameters = constructorDescriptor.ConstructorParameters;

    IEnumerable<ConstructorParameter> allParameters = parameters;
    var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
    var accessibility = GetAccessModifier(constructorDescriptor.Accessibility);
    var readonlyKeyword = constructorDescriptor.IsReadOnly ? "readonly" : "";
    var declarationKeywords = classSymbol.GetDeclarationKeywords();
    var classDeclaration = classSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
    var parameterDeclarations = string.Join(", ", allParameters.Select(RenderParameter));
    var assignments = string.Join(" ", parameters.Select(RenderAssignment));

    var namespaceContents = $@"
            {readonlyKeyword} partial {declarationKeywords} {classDeclaration}
            {{
                {accessibility} {classSymbol.Name}({parameterDeclarations})
                {{
                    {assignments}
                }}
            }}";

    var currentSymbol = classSymbol;
    while (currentSymbol.ContainingType != null)
    {
      currentSymbol = currentSymbol.ContainingType;
      var symbolDeclaration = currentSymbol.GetDeclarationKeywords();
      var symbolName = currentSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
      namespaceContents = $@"
                partial {symbolDeclaration} {symbolName}
                {{
                    {namespaceContents}
                }}";
    }

    var source = $@"
            /// <auto-generated>
            /// This code was generated by the {nameof(QuickConstructor)} source generator.
            /// </auto-generated>

            namespace {namespaceName}
            {{
                {namespaceContents}
            }}";

    return source;
  }

  private static string RenderParameter(ConstructorParameter parameter)
  {
    StringBuilder stringBuilder = new();

    stringBuilder.Append(parameter.Type.ToDisplayString(ParameterFormat));
    stringBuilder.Append(" @");
    stringBuilder.Append(parameter.ParameterName);

    return stringBuilder.ToString();
  }

  private static string RenderAssignment(ConstructorParameter parameter)
  {
    return $"this.@{parameter.Symbol.Name} = @{parameter.ParameterName};";
  }

  private static string GetAccessModifier(Accessibility accessibility)
  {
    return accessibility switch
    {
      Accessibility.Private => "private",
      Accessibility.Internal => "internal",
      Accessibility.Protected => "protected",
      _ => "public"
    };
  }
}